# 군집 알고리즘

## 키워드 정리

- **비지도 학습**
  - 머신러닝의 한 종류로 훈련 데이터에 타깃이 없습니다.
  - 타깃이 없기 떄문에 외부의 도움 없이 스스로 유용한 무언가를 학습해야 합니다.
  - 대표적인 비지도 학습 작업은 군집, 차원 축소 등입니다.
- **히스토그램**
  - 구간별로 값이 발생한 빈도를 그래프로 표시한 것입니다.
  - 보통 x축이 값의 구간(계급)이고 y축은 발생 빈도(도수)입니다.
- **군집**
  - 비슷한 샘플끼리 하나의 그룹으로 모으는 대표적인 비지도 학습 작업입니다.
  - 군집 알고리즘으로 모은 샘플 그룹을 클러스터라고 부릅니다.


## 타깃을 모르는 비지도 학습
- 타깃이 없을 때 사용하는 머신러닝 알고리즘이 바로 **비지도 학습**(unsupervised learning)입니다. 
- 사람이 가르쳐 주지 않아도 데이터에 있는 무서인가를 학습하는 ㄱㅅ




## 과일 사진 데이터 준비하기

```python
!wget https://bit.ly/fruits_300_data -O fruits_300.npy
```

- 과일 데이터는 사과, 바나나, 파인애플을 담고 있는 흑백 사진입니다.
- 이 데이터는 넘파이 배열의 기본 저장 포맷인 npy 파일로 저장되어 있습니다.
- 넘파이에서 이 파일을 읽으려면 먼저 코랩으로 다운로드해야 합니다. 

```python
import numpy as np
import matplotlib.pyplot as plt
```

- 넘파이와 맷플롯립을 임포트합니다.


```python
fruits = np.load('fruits_300.npy')
```

- 넘파이에서 npy파일을 로드합니다. 로드할 때는 `load()` 메서드를 사용합니다.


```python
print(fruits.shape)
```

- fruits는 넘파이이 배열이고 fruits_300.npy 파일에 들어있는 모든 데이터를 담고 있습니다. 
- fruits 배열의 크기를 확인해보면

```
(300, 100, 100)
```

- 이 배열의 첫 번째 차원(300)은 샘플의 갯수를 나타냅니다.
- 두 번째 차원(100)은 이미지 높이
- 세 번째 차원(100)은 이미지 너비
- 이미지 크기는 100 X 100 입니다. 
- 각 픽셀은 넘파이 배열의 원소 하나에 대응합니다. 즉 각 배열의 크기가 100 X 100 입니다.

```python
print(fruits[0, 0, :])
```

- 이미지의 첫 번째 행을 출력합니다. 
- 3차원 배열이기 때문에 처음 2개의 인덱스를 0으로 지정하고 마지막 인덱스는 지정하지 않거나 슬라이싱 연산자를 쓰면 첫 번째 이미지의 첫 번쨰 행을 모두 선택할 수 있습니다.

```python
[  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   2   1
   2   2   2   2   2   2   1   1   1   1   1   1   1   1   2   3   2   1
   2   1   1   1   1   2   1   3   2   1   3   1   4   1   2   5   5   5
  19 148 192 117  28   1   1   2   1   4   1   1   3   1   1   1   1   1
   2   2   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1
   1   1   1   1   1   1   1   1   1   1]
```

- 첫 번째 행에 있는 픽셀 100개에 들어 있는 값을 출력했습니다.
- 이 넘파이 배열은 흑백 사진을 담고 있으므로 0\~255까지의 정수값을 가집니다. 


```python
plt.imshow(fruits[0], cmap='gray')
plt.show()
```

- 정수값에 대해 더 설명하기 전에 먼저 첫 번째 이미지를 그림으로 그려서 이 숫자와 비교합니다.
- 맷 플롯립의 `imshow()` 함수를 사용하면 넘파이 배열로 지정된 이미지를 쉽게 그릴 수 있습니다. 흑백 이미지이므로 `cmap` 매개변수를 `gray`로 지정합니다.
- 0에 가까울수록 검게 나타나고 높은 값은 밝게 표시됩니다.

- 첫 번째 행에 있는 필셀 100개에 들어 있는 값을 출력했습니다. 이 넘파이 배열은 흑백 사진을 담고 있으므로 0\~255까지의 정수값을 가집니다. 
- 맷플롯립의 `imshow()` 함수를 사용하면 넘파이 배열로 저장된 이미지를 쉽게 그릴 수 있습니다. 흑백 이미지이므로 cmap 매개변수를 `gray`로 지정합니다.


![스크린샷 2024-11-10 오전 11 19 29](https://github.com/user-attachments/assets/959bc3a1-ac13-4aed-a364-43d6466e7f0f)

- 첫 번째 이미지는 사과입니다. 첫 번째 행이 위에서 출력한 배열 값에 해당합니다.
- 0에 가까울수록 검게 나타나고 높은 값은 밝게 표시됩니다.

![스크린샷 2024-11-10 오전 11 19 45](https://github.com/user-attachments/assets/ea22b04d-f038-4535-bbb3-517047384aa5)

- 보통 흑백 샘플 이미지는 바탕이 밝고 물체(여기에서는 사과)가 짙은 색입니다. 이렇게 보이는 이유는 이 흑백 이미지가 사진으로 찍은 이미지를 넘파이 배열로 변환할 때 반전시킨 것입니다.
- 사진의 흰 바탕(높은 값)은 검은색(낮은 값)으로 만들고 실제 사과가 있어 짙은 부분(낮은 값)은 밝은색(높은 값)으로 바뀌었습니다.

![스크린샷 2024-11-10 오전 11 20 00](https://github.com/user-attachments/assets/d265cc6c-297d-4cf1-9bf8-e60a451791f1)

- 우리의 관심 대상은 바탕이 아니라 사과입니다. 흰색 바탕은 우리에게 중요하지 않지만 컴퓨터는 255에 가까운 바탕에 집중할 것입니다. 따라서 바탕을 검게 만들고 사진에 짙게 나온 사과를 밝은 색으로 만들었습니다.

> 컴퓨터는 왜 255에 가까운 바탕에 집중하나요?
>
> 알고리즘이 어떤 출력을 만들기 위해 곱셈, 덧셈을 합니다. 픽셀값이 0이면 출력도 0이 되어 의미가 없습니다. 픽셀값이 높으면 출력값도 커지기 때문에 의미를 부여하기 좋습니다.


```python
plt.imshow(fruits[0], cmap='gray_r')
plt.show()
```

- 우리가 보는 것과 컴퓨터가 처리하는 방식이 다르기 때문에 종종 흑백 이미지를 이렇게 반전하여 사용합니다.
- 관심 대상의 영역을 높은 값으로 바꾸었지만 맷플롯립으로 출력할 때 바탕이 검게 나오므로 보기에는 좋지 않습니다. 
- `cmap` 매개변수를 `gray_r` 로 지정하면 다시 반전하여 우리 눈에 보기 좋게 출력합니다.

![스크린샷 2024-11-10 오전 11 20 14](https://github.com/user-attachments/assets/e8f9a964-80f0-4853-96df-99f80eeab835)

- 이 그림에서 밝은 부분이 0에 가깝고 짙은 부분이 255에 가까운 값이라는 것 

```python
fig, axs = plt.subplots(1, 2)
axs[0].imshow(fruits[100], cmap='gray_r')
axs[1].imshow(fruits[200], cmap='gray_r')
plt.show()
```

- 이 데이터는 사과, 바나나, 파인애플이 각각 100개씩 들어 있습니다. 바나나와 파인애플 이미지도 출력합니다.


![스크린샷 2024-11-10 오전 11 32 17](https://github.com/user-attachments/assets/9ebb255f-e0a5-44ad-a3cc-55abbcfe4d8a)


- 맷플롯립의 `subplots()` 함수를 사용하면 여러 개의 그래프를 배열처럼 쌓을 수 있도록 도와줍니다. 
- `subplots()` 함수의 두 매개변수는 그래프를 쌓을 행과 열을 지정합니다. 여기에서는 `subplots(1, 2)` 처럼 하나의 행과 2개의 열을 지정했습니다.
- 반환된 axs는 2개의 서브 그래프를 담고 있는 배열입니다. axs\[0\]에 파인애플 이미지를, 그리고 axs\[1\]에 바나나 이미지를 그렸습니다. 이 장에서 `subplots()`를 사용해 한 번에 여러 개의 이미지를 그려 보겠습니다.
- 샘플 데이터가 준비되었습니다. 이 데이터의 처음 100개는 사과, 그 다음 100개는 파인애플, 마지막 100개는 바나나입니다. 각 과일 사진의 평균을 내서 차이를 확인해 봅시다.

## 픽셀 값 분석하기

- 사용하기 쉽게 fruits 데이터를 사과, 파인애플, 바나나로 각각 나누어 봅시다. 넘파이 배열을 나울 때 100 X 100 이미지를 펼쳐서 길이가 10,000인 1차원 배열로 만듭니다.
- 이렇게 펼치면 이미지로 출력하긴 어렵지만 배열을 계산할 때 편리합니다.


```python
apple = fruits[0:100].reshape(-1, 100*100)
pineapple = fruits[100:200].reshape(-1, 100*100)
banana = fruits[200:300].reshape(-1, 100*100)
```

- `fruits` 배열에서 순서대로 100개씩 선택하기 위해 슬라이싱 연산자를 사용합니다. 
- 그 다음 `reshape()` 메서드를 사용해 두 번째 차원(100)과 세 번째 차원(100)을 10,000으로 합칩니다.
- 첫 번째 차원을 -1로 지정하면 자동으로 남은 차원을 할당합니다. 여기에서는 첫 번째 차원이 샘플의 갯수 입니다.


```python
print(apple.shape)
```

- 이제 apple, pineapple, banana 배열의 크기는 (100, 10000)입니다. 사과를 학인해 봅니다.

```
(100, 10000)
```

```python
print(apple.mean(axis=1))
```

- 이제 apple, pineapple, banana 배열에 들어 있는 샘플의 픽셀 평균값을 계산해 봅시다. 
- 넘파이 `mean()` 메서드를 사용합니다. 
- 샘플마다 픽셀의 평균값을 계산해야 하므로 `mean()` 메서드가 평균을 계산할 축을 지정해야 합니다. 
- `axis=0` 으로 하면 첫 번째 축인 행을 따라 계산합니다. 
- `axis=1` 로 지정하면 두 번째 축인 열을 따라 계산합니다.
- 필요한 것은 샘플의 평균값이므로 `axis=1`로 지정하여 평균을 계싼합니다.
- 평균을 계산하는 넘파이 `np.mean()` 함수를 사용해도 되지만 넘파이 배열은 이런 함수들을 메서드로 제공합니다. 
- apple 배열의 `mean()` 메서드로 각 샘플의 픽셀 평균값을 계산해 봅시다.

```
[ 88.3346  97.9249  87.3709  98.3703  92.8705  82.6439  94.4244  95.5999
  90.681   81.6226  87.0578  95.0745  93.8416  87.017   97.5078  87.2019
  88.9827 100.9158  92.7823 100.9184 104.9854  88.674   99.5643  97.2495
  94.1179  92.1935  95.1671  93.3322 102.8967  94.6695  90.5285  89.0744
  97.7641  97.2938 100.7564  90.5236 100.2542  85.8452  96.4615  97.1492
  90.711  102.3193  87.1629  89.8751  86.7327  86.3991  95.2865  89.1709
  96.8163  91.6604  96.1065  99.6829  94.9718  87.4812  89.2596  89.5268
  93.799   97.3983  87.151   97.825  103.22    94.4239  83.6657  83.5159
 102.8453  87.0379  91.2742 100.4848  93.8388  90.8568  97.4616  97.5022
  82.446   87.1789  96.9206  90.3135  90.565   97.6538  98.0919  93.6252
  87.3867  84.7073  89.1135  86.7646  88.7301  86.643   96.7323  97.2604
  81.9424  87.1687  97.2066  83.4712  95.9781  91.8096  98.4086 100.7823
 101.556  100.7027  91.6098  88.8976]
```

```python
plt.hist(np.mean(apple, axis=1), alpha=0.8)
plt.hist(np.mean(pineapple, axis=1), alpha=0.8)
plt.hist(np.mean(banana, axis=1), alpha=0.8)
plt.legend(['apple', 'pineapple', 'banana'])
plt.show()
```

- 사과 샘플 100개에 대한 픽셀 평균값을 계산했습니다. 히스토그램(histogram)을 그려보면 평균값이 어떻게 분포되어 있는지 한눈에 잘 볼 수 있습니다.
- 맷플롯립의 `hist()` 함수를 사용해 히스토그램을 그려보겠습니다. 사과, 파인애플, 바나나에 대한 히스토그램을 모두 겹쳐 그려봅니다. 이렇게 하려면 조금 투명하게 해야 겹친 부분을 잘 볼 수 이습니다.
- `alpha` 매개변수를 1보다 작게 하면 투명도를 줄 수 있습니다.
- `legend()` 함수를 사용해 어떤 과일의 히스토그램인지 범례를 만들어 봅시다.


![스크린샷 2024-11-10 오전 11 51 59](https://github.com/user-attachments/assets/b3fd20c5-6317-466e-937a-6e474a6c7e70)

- 히스토그램을 보면 바나나 사진의 평균값은 40 아래에 집중되어 있습니다. 사과와 파인애플은 90\~100사이에 많이 모여 있습니다. 
- 바나나는 픽셀 평균값만으로 사과나 파인애플과 확실히 구분됩니다. 바나나는 사진에서 차지하는 영역이 작기 때문에 평균값이 작습니다.
- 반면 사과와 파인애플은 많이 겹쳐있어서 픽셀만으로는 구분하기 쉽지 않습니다. 사과나 파인애플은 대체로 형태가 동그랗고 사진에서 차지하는 크기도 비슷하기 때문입니다.

> 히스토그램
>
> 히스토그램은 값이 발생한 빈도를 그래프로 표시한 것입니다. 보통 x축이 값의 구간(계급)이고, y축은 발생 빈도(도수)입니다. 


```python
fig, axs = plt.subplots(1, 3, figsize=(20, 5))
axs[0].bar(range(10000), np.mean(apple, axis=0))
axs[1].bar(range(10000), np.mean(pineapple, axis=0))
axs[2].bar(range(10000), np.mean(banana, axis=0))
plt.show()
```

- 좀더 나은 방법을 생각해 보면, 샘플의 평균값이 아니라 픽셀별 평균값을 비교해보면 됩니다. 전체 샘플에 대해 각 픽셀의 평균을 계산하는 것, 세 과일은 모양이 다르므로 픽셀값이 높은 위치가 조금 다를 것 같습니다.
- 픽셀의 평균을 계산하는 것도 간단합니다. `axis=0` 으로 지정하면 됩니다. 
- 그럼 맷플롯립의 `bar()` 함수를 사용해 픽셀 10,000개에 대한 평균값을 막대그래프로 그려 봅니다. `subplots()` 함수로 3개의 서브 그래프를 만들어 사과, 파인애플, 바나나에 대한 막대 그래프를 그려 봅니다.

![스크린샷 2024-11-10 오후 12 36 57](https://github.com/user-attachments/assets/77e09b77-9919-4393-bba0-1f0240ed21de)



```python
apple_mean = np.mean(apple, axis=0).reshape(100, 100)
pineapple_mean = np.mean(pineapple, axis=0).reshape(100, 100)
banana_mean = np.mean(banana, axis=0).reshape(100, 100)

fig, axs = plt.subplots(1, 3, figsize=(20, 5))
axs[0].imshow(apple_mean, cmap='gray_r')
axs[1].imshow(pineapple_mean, cmap='gray_r')
axs[2].imshow(banana_mean, cmap='gray_r')
plt.show()
```

## 평균값과 가까운 사진 고르기

```python
abs_diff = np.abs(fruits - apple_mean)
abs_mean = np.mean(abs_diff, axis=(1,2))
print(abs_mean.shape)
```

```
(300,)
```

```python
pple_index = np.argsort(abs_mean)[:100]
fig, axs = plt.subplots(10, 10, figsize=(10,10))
for i in range(10):
    for j in range(10):
        axs[i, j].imshow(fruits[apple_index[i*10 + j]], cmap='gray_r')
        axs[i, j].axis('off')
plt.show()
```
